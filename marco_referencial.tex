\chapter{Marco Referencial} % (fold)
\label{cha:marco_referncial}

  \section{Node JS}
  \label{sec:node_js}
    Node.js aparecio en 2009 y esta construido sobre el Motor de JavaScript de Google ``V8'' que fue sacado del browser y aplicado en el servidor.

    Para desarrollar en el lado del browser (cliente) el programador solo tiene disponible JavaScript como lenguaje de desarrollo pero en el lado del servidor existen muchas alternativas (Ruby, C\#, Phtyon, Java, etc.), JavaScript no estaba disponible.\\

    Node se beneficia del Motor de JavaScript ``V8'' ya que \'este es r\'apido y tiene integrado un sistema para manejar las instrucciones de forma asyncr\'onica, pero el mayor beneficio y el porqu\'e Node adquiri\'o una gran popularidad es la facilidad de compartir c\'odigo entre el cliente (browser) y el servidor.\\

    Node.js provee caracter\'isticas pero estas pueden parecer complicadas o que necesitan mas instrucciones de las necesarias para llevar a cabo acciones que ya son comunes en la creacion de aplicacion en lado del servidor, por ejemplo a la hora de crear un servidor web, Node se popularizo en gran medida por poder crear servidores web personalizables pero como ya dijimos esto tiene su grado de complejidad, aca es donde entra en accion Express.js.

  % end section node js
  \section{Express JS}
  \label{sec:express_js}
    Express.js es un framework que esta construido sobre la funcionalidad de servidor web de Node.js, Express.js ayuda a simplificar el API de Node y a\~nadir nuevas caracter\'isticas, dise\~nadas para mejorar y facilitar la organizaci\'on de una aplicaci\'on \emph{Express}.\\

    El Cliente (navegador web, aplicacion movil, etc) envia una peticion web y el servidor web de Node.js maneja los protocolos web, leyendolos y enviandolos a una aplicacion \emph{Express} que se encarga de a\~nadir caracteristicas a la peticion y espera la respuesta del ``Middleware Stack'', la funcion responde a la llamada y el servidor HTTP de Node envia la respuesta mediante los protocolos web al Cliente.\\

    Para escribir un servidor web con Express no es necesario una gran funcion para manejar un request, Express contiene utilidades que permite escribir funciones mas peque\~nas para facilitar el manejo de las peticiones web, asiendo uso de ``middleware'' y ``routing''.

    \subsection{Middleware}
    \label{sub:middleware}
      Node.js maneja una funci\'on para trabajar con una peticion web, encambio \emph{Express} maneja la llamada con varias funciones, cada funcion se encarga de una peque\~na parte del trabajo. Estas peque\~nas funciones que manejan la peticion web se denomina \emph{Middleware functions} o Middleware.

    %  end sub section middleware

    \subsection{Routing}
    \label{sub:routing}
      Muy parecido al Middleware, el Routing se encarga de partir una funcion de peticion web monolitica en peque\~nas piezas, pero a diferencia del Middleware, estos menajadores peticiones se ejecutan condicionalmente dependidiendo del URL y el metodo HTTP (GET, POST, DELETE) que el cliente envia.\\

    %  end sub section routing

    Express.js es bastante extensible y cuenta con gran popularidad en la comunidad de desarrollo, la cual provee herramientas para renderizar dinamicamente HTML o interfaces para comunicarse con Bases de Datos, por ejemplo para manejar la coneccion y llamadas a una base de datos en PostgreSQL se uso la libreria \emph{pg-promise}.

    \begin{lstlisting}[language=Java]
      database.any("SELECT * FROM users WHERE id = $1", [userId])
        .then(function (data) {
            response.send(data.name);
        });
    \end{lstlisting}


  % section Express JS (end)

  % \section{Introducci\'on} % (fold)
  % \label{sec:Introduccion}

  % % section Introduccion (end)

  % \section{Ruby on Rails} % (fold)
  % \label{sec:ruby_on_rails}
  %   Ruby on Rails es un framework dise\~nado para desarrollar aplicaciones web,
  %   y está construido sobre el lenguaje de programación Ruby, Ruby  fue creado
  %   alrededor de 1993 por Yukihiro ``Matz'' Matsumuto de Jap\'on, y liberado al
  %   público en 1995, y desde entonces fue ganando  popularidad y
  %   reputaci\'on gracias al aporte de una gran variedad de programadores, que
  %   realzan la sintaxis elegante y el código limpio que se genera, Ruby es un
  %   lenguaje de programación multiparadigma ya que implementa programaci\'on
  %   Orientado a Objetos, programaci\'on Funcional así como también
  %   programaci\'on Imperativa. \\
  %
  %   Ruby on Rails fue creado en el 2004 por David Heinemeier Hansson durante el desarrollo de Basecamp, una aplicación de gesti\'on de proyectos, y una vez que se necesitó para otros proyectos, el equipo de desarrollo extrajo el core de funcionalidad el cual fue presentado al público en julio del 2004 con el nombre de Ruby on Rails, como proyecto Open Source bajo una licencia MIT, desde entonces tuvo un gran  crecimiento impulsado por la comunidad de usuarios que continuamente están desarrollando nuevas características, limpiando bugs y creando gemas\footnote{ Los plugins o complementos, en el lenguaje Ruby son llamados \textbf{gemas}}. La última versión de Rails es la 3.2 publicado en enero del 2012 y actualmente está en su revisi\'on 3.2.8 presentado en agosto del 2012,  demostrando que el equipo de desarrollo de Rails esta trabajando constantemente en mejorar este framework que actualmente está entre los mejores en desarrollo web.\\
  %    % y se prevee que la versión 4 de Rails sea lanzada a finales del 2012, pero no  \\
  %   % y para el proyecto se utilizó la versión 3.2.3
  %
  %   El núcleo de funcionalidad de Rails es un conjunto de funciones llamadas \emph{Railties}:
  %   \begin{description}
  %     \item[Active Record] Es una implementaci\'on del patrón
  %       Object-Relational Mapping(ORM), que mapea las tablas de la Base de datos relacional en clases, filas en objetos y
  %       columnas en atributos de los objetos.
  %     \item[Active Support] Es el componente de Rails responsable de proporcionar extensiones del lenguaje Ruby, utilitarios y funciones primordiales a la hora de realizar cualquier tarea en el desarrollo de la aplicaci\'on.
  %     \item[Action Mailer] Permite enviar correo electrónico (email) desde la aplicaci\'on usando un  modelo y vistas.
  %     \item[Action Pack] Es el responsable de manejar y responder los request del navegador web. Provee las herramientas para el \textbf{routing}, define los \textbf{controladores}, y genera las respuestas renderizando las \textbf{vistas}. En resumen, Action Pack maneja las capas de la vista y el controlador del paradigma MVC.
  %   \end{description}
  %   Otra de las características de Rails es la facilidad para escribir Pruebas, en realidad Rails sugiere el modelo de Desarrollo guiado por Pruebas(TDD\footnote{Test-Driven Development, por sus siglas en Inglés}), que consiste en 3 pasos
  %   \begin{enumerate}
  %     \item \textbf{Rojo}, la prueba falla
  %     \item \textbf{Verde}, la prueba pasa
  %     \item \textbf{Refactorizar}, limpiar el código
  %   \end{enumerate}
  %   Para este proceso, Rails ofrece primeramente el módulo Test::Unit, pero también se pueden encontrar variadas herramientas para llevar a cabo está tarea.\\
  %
  %   Ruby on Rails es un framework MVC, que implementa los principios REST, No te Repitas\footnote{DRY, Don't Repit Yourself}, Convenci\'on sobre Configuraci\'on, estas características de Rails están explicadas con mayor detalle en el capítulo \ref{cha:ruby_on_rails_y_patrones_web_2_0}.


  % section ruby_on_rails (end)

  \section{Base de Datos} % (fold)
  \label{sec:base_de_datos}

    En una aplicación web es necesario alguna forma de persistencia de datos, en especial si se están usando datos complejos y en gran cantidad, para realizar está tarea, la base de datos es un factor primordial.
    Rails maneja la base de datos mediante  un ORM, por lo tanto la base de datos que se utilice no es tan excluyente, en este caso se utilizó  \emph{PostgreSQL} como base de datos relacional.\\

    \subsection{PostgreSQL} % (fold)
    \label{sec:postgres}

      PostgreSQL es un sistema de gestión de bases de datos objeto-relacional, Open Source y distribuido bajo licencia BSD.
      PostgreSQL utiliza un modelo cliente/servidor y usa multiprocesos en vez de multihilos para garantizar la estabilidad del sistema. Un fallo en uno de los procesos no afectará el resto y el sistema continuará funcionando.
      La última versi\'on de PostgreSQL es la 9.5, su desarrollo comenz\'o hace más de 16 años, y cuenta con una gran comunidad que aporta con el desarrollo, testeo de nuevas versiones.
      PostgreSQL  está considerada como una de los mejores \emph{Sistemas de gesti\'on de bases de datos}, es muy completo y está muy bien documentado\footnote{ http://www.postgresql.org/docs/9.5/static/}.
      Entre sus características se pueden nombrar las siguientes.
      \begin{itemize}
        \item Es una base de datos 100\% ACID\footnote{  ACID es un acrónimo de Atomicity, Consistency, Isolation and Durability}
        \item Integridad referencial
        \item Replicación asincrónica/sincrónica
        \item Múltiples métodos de autentificación
        \item Disponible para Linux y UNIX en todas sus variantes
        \item Funciones/procedimientos almacenados
        \item Soporte a la especificaci\'on SQL
      \end{itemize}

      Personalmente se escogió trabajar con  PostgreSQL como DBMS
      porque cuenta con una extensa documentación,  y gracias a su caracter ``Open Source'', y su gran flexibilidad en poder definir nuevos tipos de datos,
      se hace posible que empresas como \textbf{Refractions Research} puedan crear recursos como PostGIS, necesario para trabajar con datos geográficos \'o espaciales.

      % Entre sus principales  características se puede nombrar que es
      % \footnote{ DBMS, DataBase Management System}
      % y durante este tiempo, estabilidad, potencia, robustez, facilidad de administración e implementación de estándares han sido las características que más se han tenido en cuenta durante su desarrollo. PostgreSQL funciona muy bien con grandes cantidades de datos y una alta concurrencia de usuarios accediendo a la vez a el sistema.

    % section postgres (end)

    \subsection{PostGis} % (fold)
    \label{sec:postgis}

      PostGIS es un módulo  que a\~nade soporte de objetos geográficos al DBMS PostgreSQL, convirtiéndola en una base de datos espacial para su utilización en un Sistema de Informaci\'on Geografica(SIG\footnote{ Es bastante común utilizar el acrónimo en Inglés, Geographic Information System (GIS), de hay viene el término de PostGIS = Postgres + GIS}).

      El desarrollo de PostGIS está a cargo de \textbf{Refractions Research}, está liberada con la \emph{Licencia pública general de GNU}, declarandola como software libre y lo protege de cualquier intento de apropiaci\'on.\\

      PostGIS implementa la especificaci\'on ``SFSQL'' (Simple Features for SQL, define los tipos y funciones que necesita implementar cualquier base de datos espacial) de la OGC (Open Geospatial Consortium, es un consorcio internacional, formado por un conjunto de empresas, agencias gubernamentales y universidades, dedicado a desarrollar especificaciones de interfaces para promover y facilitar el uso global de la información espacial).\\

      PostGIS al igual que PostgreSQL tiene una documentaci\'on bastante extensa, y cuenta con equipo de desarrollo que continuamente va sacando nuevas versiones, actualmente se encuentra la versi\'on 2.0.1, pero para el desarrollo de la aplicaci\'on se hizo uso de la versi\'on 1.5.5.

      PostGIS es gratis, pero no por ello es una herramienta de baja calidad, al contrario se la considera una herramienta de nivel empresarial, y muchas instituciones la est\'an usando de manera exitosa\footnote{ http://www.postgis.org/documentation/casestudies/}, aparte de numerosas aplicaciones \\

      Manejar los datos geográficos con PostGIS es sencillo y muy eficiente, por está raz\'on se utilizó está herramienta, pero para conseguir la ruta óptima entre 2 puntos se necesitaba el uso del algoritmo de Dijkstra y para PostGIS existe el módulo \textbf{PgRouting}, que tiene implementado este algoritmo.

      \subsubsection{pgRouting} % (fold)
      \label{sec:pgrouting}
        pgRouting es una extensi\'on  de  PostGIS para proveer funcionalidades de ruteo espacial. pgRouting es un desarrollo posterior de pgDijkstra y actualmente está siendo mantenido por Georepublic, la última versi\'on estable es la 2.1, y es la que fue usada para desarrollar el sistema.\\

        Las ventajas del ruteo en la base de datos son:
        \begin{itemize}
          \item Los datos y atributos pueden ser modificados desde varios clientes, como Quantum GIS y uDig a través de JDBC, ODBC, o directamente usando Pl/pgSQL. Los clientes pueden ser PCs o dispositivos móviles.
          \item Los cambios pueden ser reflejados instantáneamente a través del motor de ruteo. No hay necesidad de hacer cálculos previos.
          \item El parámetro de ``costo'' puede ser calculado dinámicamente a través de SQL y su valor puede provenir de múltiples campos y tablas.
        \end{itemize}

        pgRouting provee funciones para:
        \begin{itemize}
          \item Camino mínimo (Dijkstra): algoritmo de ruteo sin heurística
          \item Camino mínimo (A-Star): routeo para conjunto de datos grandes (con heurística)
          \item Camino mínimo (Shooting-Star): ruteo con restricciones de giro (con heurística)
          \item El problema del viajante (TSP: Traveling Salesperon Problem)
          \item Cálculo de ruta (Isolíneas)
        \end{itemize}

        % Uses PostGIS for its geographic data format, which in turn uses OGC’s data format Well Konwn Text (WKT) and Well Known Binary (WKB)
      % section pgrouting (end)
    % section postgis (end)
  % section base_de_datos (end)

  \section{Metodologia de Desarrollo}
  \label{sec:metodologia_de_desarrollo}
    La metodologia para el desarrollo de software nos permite gestionar y administrar un proyecto de desarrollo de software para llevarlo a termino de una forma mas eficiente y con altas probabilidades de exito.
    Para este proyecto de grado se va a ser uso de una de las metodologias agiles \emph{SCRUM}.

    \subsection{SCRUM}
    \label{sub:scrum}

      \begin{quote}

        Un marco de trabajo por el cual las personas pueden acometer problemas complejos adaptativos, a la vez que entregar productos del máximo valor posible productiva y creativamente.\footnote{http://www.scrumguides.org/docs/scrumguide/v1/Scrum-Guide-ES.pdf}

      \end{quote}

      Scrum fue creado en 1993 por Jeff Sutherland, el termino \emph{scrum} fue tomado de un estudio de 1986 de Takeuchi y Nonaka \footnote{https://hbr.org/1986/01/the-new-new-product-development-game} en el cual comparan equipos de alto rendimiento y multidisiplinarios con la formacion \emph{scrum} usado por equipos de Rugby.\cite{why_scrum}.\\

      Scrum es un marco de trabajo el cual especifica roles, procesos, actvidades y artefactos pero eso no quiere decir que sea una receta que haya que seguir al pie de la letra, encambio es una guia que nos permitara organizarnos, a continuacion se describira las caracteristicas que se usaran en el desarrollo del presente proyecto de grado.


      % The Scrum framework in 30 seconds
      % A product owner creates a prioritized wish list called a product backlog.
      % During sprint planning, the team pulls a small chunk from the top of that wish list, a sprint backlog, and decides how to implement those pieces.
      % The team has a certain amount of time — a sprint (usually two to four weeks) — to complete its work, but it meets each day to assess its progress (daily Scrum).
      % Along the way, the ScrumMaster keeps the team focused on its goal.
      % At the end of the sprint, the work should be potentially shippable: ready to hand to a customer, put on a store shelf, or show to a stakeholder.
      % The sprint ends with a sprint review and retrospective.
      % As the next sprint begins, the team chooses another chunk of the product backlog and begins working again.
      % - See more at: https://www.scrumalliance.org/why-scrum#sthash.U15K98Xq.dpuf
      %

      \subsubsection{El Equipo Scrum (Scrum Team)}
      \label{subs:scrum_team}

      El Equipo Scrum consiste en un Dueño de Producto (Product Owner), el Equipo de Desarrollo       (Development Team) y un Scrum Master. Los Equipos Scrum son autoorganizados y      multifuncionales. Los equipos autoorganizados eligen la mejor forma de llevar a cabo su trabajo y no son dirigidos por personas externas al equipo. Los equipos multifuncionales tienen todas las competencias necesarias para llevar a cabo el trabajo sin depender de otras personas que no son parte del equipo. El modelo de equipo en Scrum está diseñado para optimizar la flexibilidad, la creatividad y la productividad.

      \begin{description}
        \item[Due\~no de Producto (Product Owner)] Debe ser una persona con vision, autoridad y disponibilidad. Es el experto del producto y las prioridades y necesidades del cliente. Trabaja con el equipo de desarrollo aclarando dudas acerca de los requerimientos. Es la persona encargada de charlar con los clientes y traducir sus necesidades para el equipo de desarrollo.\\
        El rol de \emph{product owner} estara a cargo del docente de la materia de Proyecto Final.

        \item[El equipo de Desarrollo] Es el grupo de personas que hacen el trabajo de crear el producto, dentro de este rol entran los programadores, testers, escritores, cualquier persona que forme parte del desarrolo del producto es parte del \emph{equipo de desarollo}.\\
        El rol de \emph{equipo de desarrollo} estara a cargo de mi persona.

        \item[Scrum Master] Es la persona responsable de asegurase que el equipo de desarrollo entiende e implementa \emph{Scrum}. El Scrum Master no maneja el equipo de desarrollo encambio lo ayuda a organizarse maximizando el valor creado por el equipo de desarrollo.\\
        El rol de \emph{Scrum Master} estara a cargo del Tutor.\\

        Dentro del equipo Scrum tambien se reconocen a los \emph{Stakeholders} que son personas que tienen algun interes y/o estan afectadas por el producto y pueden dar feedback hacerca de este pero no son responsables del producto. Este rol no sera implementado.

      \end{description}

      % end scrum_team

      \subsubsection{Eventos de Scrum}
      \label{subs:scrum_events}
      Eventos o actividades, estos procesos estan dise\~nados para mejorar la eficiencia  y performance del equipo scrum.

      \begin{description}
        \item[Sprint]
        El corazón de Scrum es el Sprint, es un bloque de tiempo (time-box) generalmente consistente en 2 semanas durante  cual se crea un incremento de producto “Terminado”, utilizable y potencialmente desplegable. Es más conveniente si la duración de los Sprints es consistente a lo largo del esfuerzo de desarrollo. Cada nuevo Sprint comienza inmediatamente después de la finalización del Sprint previo.

        Los Sprints contienen y consisten de la Reunión de Planificación del Sprint (Sprint Planning Meeting), los Scrums Diarios (Daily Scrums), el trabajo de desarrollo, la Revisión del Sprint (Sprint Review), y la Retrospectiva del Sprint (Sprint Retrospective).

        \item[Daily Scrum]

        El Scrum Diario es una reunión con un bloque de tiempo de 15 minutos para que el Equipo de Desarrollo sincronice sus actividades y cree un plan para las siguientes 24 horas. Esto se lleva a cabo inspeccionando el trabajo avanzado desde el último Scrum Diario y haciendo una proyección acerca del trabajo que podría completarse antes del siguiente. \\
        Durante la reunión, cada miembro del Equipo de Desarrollo explica:
        \begin{itemize}
          \item Que hize ayer?
          \item Que voy a hacer hoy?
          \item Tengo algun problema?
        \end{itemize}

      \end{description}

      % end scrum_events

      \subsubsection{Artefactos de Scrum}
      \label{subs:artefactos_de_scrum}
        Los artefactos de Scrum representan trabajo o valor en diversas formas.

        \begin{description}
          \item[Lista de Producto (Product Backlog)]

          La Lista de Producto es una lista ordenada de todo lo que podría ser necesario en el producto, y es la única fuente de requisitos para cualquier cambio a realizarse en el producto. El Dueño de Producto (Product Owner) es el responsable de la Lista de Producto, incluyendo su contenido, disponibilidad y ordenación.

          La Lista de Producto no esta escrita en piedra, se puede modificar y a\~nadir  // pero  no eliminar.  // requisitos durante el ciclo de desarrollo de software.

          \item[Lista de pendientes del Sprint (Sprint Backlog)]

          La Lista de Pendientes del Sprint es el conjunto de elementos de la Lista de Producto seleccionados para el Sprint, más un plan para entregar el Incremento de producto y conseguir el Objetivo del Sprint. La Lista de Pendientes del Sprint es una predicción hecha por el Equipo de Desarrollo acerca de qué funcionalidad formará parte del próximo Incremento y del trabajo necesario para entregar esa funcionalidad en un Incremento “Terminado”.

        \end{description}
      % end artefactos_de_scrum
    % end scrum

  % end metodologia_de_desarrollo
% chapter marco_referncial (end)
